# Reflection

## What Was Easy
- Designing the initial concept structure.
- Creating UI wireframes and flows.
- Working with basic CRUD operations.

## What Was Hard
- Debugging CORS and deployment issues.
- Ensuring sync updates propagate reliably.
- Maintaining consistent API structure across concepts.
- Understanding how concepts, syncs, and triggers interact.

## What Went Well
- The final system faithfully represents the original idea.
- Sync logic eventually produced a dynamic, responsive dashboard.
- Visual design remained mostly consistent with Assignment 4b.
- Collaboration between backend and frontend worked smoothly later on.

## Mistakes and Lessons Learned
- Underestimating complexity of sync mechanisms.
- Making changes without fully understanding server entry points.
- Not isolating breaking changes before deployment.
- Fix: commit more often, test each change in isolation.

## Skills Gained
- Handling CORS and cross-domain requests.
- Structuring concept-based applications.
- Debugging SSR/serverless deployment issues.
- Stronger understanding of real-time update patterns.

## Skills to Develop Further
- More experience with testing frameworks.
- Clearer understanding of deployment pipelines.
- Better planning around backendâ€“frontend integration.

## Use of Context Tool
- Used to store evolving concept definitions.
- Helpful for tracking task and notification behaviours.
- Assisted in understanding the impact of design changes.

## Use of Agentic Coding Tools
- Used to generate boilerplate concepts and syncs.
- Helped detect API inconsistencies.
- Accelerated development but sometimes produced breaking changes that required manual debugging.

## Conclusion About LLMs in Software Development
- Useful for generating structure and boilerplate.
- Excellent for refactoring, explanations, and debugging logs.
- Should not be trusted without verification, especially for:
  - server configuration
  - CORS
  - production deployment
- Best used as an assistant, not an autonomous engineer.
